# of type, 'old.str':'new.str'
# used in conjunction with rpl_cols
# to allow user to clean out unwanted values
replace_dict = c(),
# dictate whether replacer function
# glides over NAs, or, user can elect to
# change to FALSE, and
ignore_na = TRUE,
# provide a na_replacer value- and the function
# will replace all NAs with this value
na_replacer = FALSE,
sampling_type = NULL){
#checks
filepath_supplied <-  ! missing(filepath) && ! is.null(filepath)
tibble_supplied <-  ! missing(preprocessed_tibble) && ! is.null(preprocessed_tibble)
if(filepath_supplied && tibble_supplied){
stop(glue('Only one of filepath and preprocessed_tibble can be supplied. ',
'preprocessed_tibble is for rare circumstances only.'))
}
if(! datetime_tz %in% OlsonNames()){
stop('datetime_tz must be included in OlsonNames()')
}
if(length(data_cols) == 1 &&
! (missing(var_flagcol_pattern) || is.null(var_flagcol_pattern))){
stop(paste0('Only one data column. Use summary_flagcols instead ',
'of var_flagcol_pattern.'))
}
if(any(! is.logical(is_sensor))){
stop('all values in is_sensor must be logical.')
}
svh_names <- names(is_sensor)
if(
length(is_sensor) != 1 &&
(is.null(svh_names) || any(is.na(svh_names)))
){
stop('if is_sensor is not length 1, all elements must be named.')
}
if(! all(data_cols %in% ms_vars$variable_code)) {
for(i in 1:length(data_cols)) {
if(!data_cols[i] %in% ms_vars$variable_code) {
logerror(msg = paste(unname(data_cols[i]), 'is not in varibles.csv; add'),
logger = logger_module)
}
}
}
if(! is.null(sampling_type)){
if(! length(sampling_type) == 1){
stop('sampling_type must be a length of 1')
}
if(! sampling_type %in% c('G', 'I')){
stop('sampling_type must be either I or G')
}
}
#parse args; deal with missing args
datetime_colnames <- names(datetime_cols)
datetime_formats <- unname(datetime_cols)
alt_datacols <- var_flagcols <- alt_varflagcols <- NA
alt_datacol_names <- var_flagcol_names <- alt_varflagcol_names <- NA
if(missing(summary_flagcols)){
summary_flagcols <- NULL
}
if(missing(set_to_NA)) {
set_to_NA <- NULL
}
if(missing(alt_site_code)) {
alt_site_code <- NULL
}
#fill in missing names in data_cols (for columns that are already
#   canonically named)
datacol_names0 <- names(data_cols)
if(is.null(datacol_names0)) datacol_names0 <- rep('', length(data_cols))
datacol_names0[datacol_names0 == ''] <-
unname(data_cols[datacol_names0 == ''])
#expand data columnname wildcards and rename data_cols
datacol_names <- gsub_v(pattern = '#V#',
replacement_vec = datacol_names0,
x = data_col_pattern)
names(data_cols) <- datacol_names
#expand alternative data columnname wildcards and populate alt_datacols
if(! missing(alt_datacol_pattern) && ! is.null(alt_datacol_pattern)){
alt_datacols <- data_cols
alt_datacol_names <- gsub_v(pattern = '#V#',
replacement_vec = datacol_names0,
x = alt_datacol_pattern)
names(alt_datacols) <- alt_datacol_names
}
#expand varflag columnname wildcards and populate var_flagcols
if(! missing(var_flagcol_pattern) && ! is.null(var_flagcol_pattern)){
var_flagcols <- data_cols
var_flagcol_names <- gsub_v(pattern = '#V#',
replacement_vec = datacol_names0,
x = var_flagcol_pattern)
names(var_flagcols) <- var_flagcol_names
}
#expand alt varflag columnname wildcards and populate alt_varflagcols
if(! missing(alt_varflagcol_pattern) && ! is.null(alt_varflagcol_pattern)){
alt_varflagcols <- data_cols
alt_varflagcol_names <- gsub_v(pattern = '#V#',
replacement_vec = datacol_names0,
x = alt_varflagcol_pattern)
names(alt_varflagcols) <- alt_varflagcol_names
}
#combine all available column name mappings; assemble new name vector
colnames_all <- c(data_cols, alt_datacols, var_flagcols, alt_varflagcols)
na_inds <- is.na(colnames_all)
colnames_all <- colnames_all[! na_inds]
suffixes <- rep(c('__|dat', '__|dat', '__|flg', '__|flg'),
times = c(length(data_cols),
length(alt_datacols),
length(var_flagcols),
length(alt_varflagcols)))
suffixes <- suffixes[! na_inds]
colnames_new <- paste0(colnames_all, suffixes)
colnames_all <- c(datetime_colnames, colnames_all)
names(colnames_all)[1:length(datetime_cols)] <- datetime_colnames
colnames_new <- c(datetime_colnames, colnames_new)
if(! missing(site_code_col) && ! is.null(site_code_col)){
colnames_all <- c('site_code', colnames_all)
names(colnames_all)[1] <- site_code_col
colnames_new <- c('site_code', colnames_new)
}
if(! is.null(summary_flagcols)){
nsumcol <- length(summary_flagcols)
summary_flagcols_named <- summary_flagcols
names(summary_flagcols_named) <- summary_flagcols
colnames_all <- c(colnames_all, summary_flagcols_named)
colnames_new <- c(colnames_new, summary_flagcols)
}
#assemble colClasses argument to read.csv
classes_d1 <- rep('numeric', length(data_cols))
names(classes_d1) <- datacol_names
classes_d2 <- rep('numeric', length(alt_datacols))
names(classes_d2) <- alt_datacol_names
classes_f1 <- rep('character', length(var_flagcols))
names(classes_f1) <- var_flagcol_names
classes_f2 <- rep('character', length(alt_varflagcols))
names(classes_f2) <- alt_varflagcol_names
classes_f3 <- rep('character', length(summary_flagcols))
names(classes_f3) <- summary_flagcols
class_dt <- rep('character', length(datetime_cols))
names(class_dt) <- datetime_colnames
if(! missing(site_code_col) && ! is.null(site_code_col)){
class_sn <- 'character'
names(class_sn) <- site_code_col
}
classes_all <- c(class_dt, class_sn, classes_d1, classes_d2, classes_f1,
classes_f2, classes_f3)
classes_all <- classes_all[! is.na(names(classes_all))]
if(filepath_supplied){
d <- read.csv(filepath,
stringsAsFactors = FALSE,
colClasses = "character")
} else {
d <- mutate(preprocessed_tibble,
across(everything(), as.character))
}
d <- item_replace(d, rpl_cols, replace_dict, ignore_na, na_replacer)
d <- d %>%
as_tibble() %>%
select(one_of(c(names(colnames_all), 'NA.'))) #for NA as in sodium
if('NA.' %in% colnames(d)) class(d$NA.) = 'character'
# Remove any variable flags created by pattern but do not exist in data
# colnames_all <- colnames_all[names(colnames_all) %in% names(d)]
# classes_all <- classes_all[names(classes_all) %in% names(d)]
# Set values to NA if used as a flag or missing data indication
# Not sure why %in% does not work, seem to only operate on one row
if(! is.null(set_to_NA)){
for(i in 1:length(set_to_NA)){
d[d == set_to_NA[i]] <- NA
}
}
#Set correct class for each column
colnames_d <- colnames(d)
for(i in 1:ncol(d)){
if(colnames_d[i] == 'NA.'){
class(d[[i]]) <- 'numeric'
next
}
class(d[[i]]) <- classes_all[names(classes_all) == colnames_d[i]]
}
# d[] <- sw(Map(`class<-`, d, classes_all)) #sometimes classes_all is too long, which makes this fail
#rename cols to canonical names
for(i in 1:ncol(d)){
if(colnames_d[i] == 'NA.'){
colnames_d[i] <- 'Na__|dat'
next
}
canonical_name_ind <- names(colnames_all) == colnames_d[i]
if(any(canonical_name_ind)){
colnames_d[i] <- colnames_new[canonical_name_ind]
}
}
colnames(d) <- colnames_d
#resolve datetime structure into POSIXct
d  <- resolve_datetime(d = d,
datetime_colnames = datetime_colnames,
datetime_formats = datetime_formats,
datetime_tz = datetime_tz,
optional = optionalize_nontoken_characters)
# datetime character enforcement
#remove rows with NA in datetime or site_code
d <- filter(d,
across(any_of(c('datetime', 'site_code')),
~ ! is.na(.x)))
#remove all-NA data columns and rows with NA in all data columns.
#also remove flag columns for all-NA data columns.
all_na_cols_bool <- apply(select(d, ends_with('__|dat')),
MARGIN = 2,
function(x) all(is.na(x)))
all_na_cols <- names(all_na_cols_bool[all_na_cols_bool])
all_na_cols <- c(all_na_cols,
sub(pattern = '__\\|dat',
replacement = '__|flg',
all_na_cols))
d <- d %>%
select(-one_of(all_na_cols)) %>%
filter_at(vars(ends_with('__|dat')),
any_vars(! is.na(.)))
#for duplicated datetime-site_code pairs, keep the row with the fewest NA
#   values. We could instead do something more sophisticated.
d <- d %>%
rowwise(one_of(c('datetime', 'site_code'))) %>%
mutate(NAsum = sum(is.na(c_across(ends_with('__|dat'))))) %>%
ungroup() %>%
arrange(datetime, site_code, NAsum) %>%
select(-NAsum) %>%
distinct(datetime, site_code, .keep_all = TRUE) %>%
arrange(site_code, datetime)
#convert NaNs to NAs, just in case.
d[is.na(d)] <- NA
#either assemble or reorder is_sensor to match names in data_cols
if(length(is_sensor) == 1){
is_sensor <- rep(is_sensor,
length(data_cols))
names(is_sensor) <- unname(data_cols)
} else {
data_col_order <- match(names(is_sensor),
names(data_cols))
is_sensor <- is_sensor[data_col_order]
}
#fix sites names if multiple names refer to the same site
if(! is.null(alt_site_code)){
for(z in 1:length(alt_site_code)){
d <- mutate(d,
site_code = ifelse(site_code %in% !!alt_site_code[[z]],
!!names(alt_site_code)[z],
site_code))
}
}
#prepend two-letter code to each variable representing sample regimen and
#record sample regimen metadata
d <- sm(identify_sampling(df = d,
is_sensor = is_sensor,
domain = domain,
network = network,
prodname_ms = prodname_ms,
sampling_type = sampling_type))
#Check if all sites are in site file
unq_sites <- unique(d$site_code)
if(! all(unq_sites %in% site_data$site_code)){
for(i in seq_along(unq_sites)) {
if(! unq_sites[i] %in% site_data$site_code){
logwarn(msg = paste(unname(unq_sites[i]),
'is not in site_data file; add?'),
logger = logger_module)
}
}
}
return(d)
}
ms_d <- ms_read_raw_csv(preprocessed_tibble = d,
datetime_cols = list('RecYear' = '%Y',
'RecMonth' = '%m',
'RecDay' = '%d',
'RecTime' = '%H%M'),
datetime_tz = 'US/Central',
site_code_col = 'WATERSHED',
alt_site_code = list('N04D' = 'n04d',
'N02B' = 'n02b',
'N20B' = 'n20b',
'N01B' = 'n01b',
'NFKC' = 'nfkc',
'HOKN' = 'hokn',
'SFKC' = 'sfkc',
'TUBE' = 'tube',
'KZFL' = 'kzfl',
'SHAN' = 'shan',
'HIKX' = 'hikx'),
data_cols =  c('NO3', 'NH4'='NH4_N', 'TN', 'SRP',
'TP', 'DOC'),
data_col_pattern = '#V#',
var_flagcol_pattern = '#V#_code',
summary_flagcols = 'check',
set_to_NA = '.',
rpl_cols = c('RecTime'),
replace_dict = c("." = 1200),
is_sensor = FALSE)
View(ms_d)
datetime_clean <- function(df,
# dictionary of form
# c('datetime_column_name' = 'datetime_type')
# 'datetime_type' options: 'time' 'day' 'month' 'year'
dt_dict,
default_dt = 1200,
# allows you to skip NAs,
# FALSE reassigns to default_dt
ignore_dt_na = TRUE,
# allows user to specify other values to
# reassign to default_dt, can be single
# or vector
replace_value = FALSE,
) {
# loop through every provided datetime_type
for (time_col in names(dt_dict)) {
# loop through every time value
for(i in 1:nrow(df[time_col])) {
# if it is NA
if (is.na(df[time_col][i, ])) {
# pass if ignore_dt_na is TRUE
if (ignore_dt_na) {
next()
# replace with default time if FALSE
} else {
df[time_col][i, ] <- default_dt
}
# if it is equal to replace_value
} else if (df[time_col][i, ] %in% replace_value) {
# replace with the default
df[time_col][i, ] <- default_dt
# if the default time is midnight
} else if (dt_dict[time_col] == 'time') {
# make sure that all entries have 4 digits
if(nchar(df[time_col][i, ]) == 1) {
df[time_col][i, ] <- paste0(000, df[time_col][i, ])
} else if(nchar(df[time_col][i, ]) == 2) {
df[time_col][i, ] <- paste0(00, df[time_col][i, ])
} else if(nchar(df[time_col][i, ]) == 3) {
df[time_col][i, ] <- paste0(0, df[time_col][i, ])
} else if(nchar(df[time_col][i, ]) == 4) {
df[time_col][i, ] <- as.character(df[time_col][i, ])
} else if(nchar(df[time_col][i, ]) > 4) {
print("ERROR: greater than 4 character entry in the time column")
}
} else if (dt_dict[time_col] == 'day'| dt_dict[time_col] == 'month') {
if(nchar(df[time_col][i, ]) == 1) {
df[time_col][i, ] <- paste0(0, df[time_col][i, ])
} else if(nchar(df[time_col][i, ]) == 2) {
df[time_col][i, ] <- as.character(df[time_col][i, ])
} else if(nchar(df[time_col][i, ]) > 2) {
print("ERROR: greater than 2 character entry in the month column")
}
} else if (dt_dict[time_col] == 'year' ) {
if(nchar(df[time_col][i, ]) == 1) {
df[time_col][i, ] <- paste0(200, df[time_col][i, ])
} else if(nchar(df[time_col][i, ]) == 2) {
df[time_col][i, ] <- paste0(20, df[time_col][i, ])
} else if(nchar(df[time_col][i, ]) == 3) {
df[time_col][i, ] <- paste0(2, df[time_col][i, ])
} else if(nchar(df[time_col][i, ]) == 4) {
df[time_col][i, ] <- as.character(df[time_col][i, ])
} else if(nchar(df[time_col][i, ]) > 4) {
print("ERROR: greater than 4 character entry in the year column")
}
} else {
print("ERROR: incorrect datetime type, options are 'time' 'day' 'month' 'year'")
}
}
}
return(df)
}
datetime_clean <- function(df,
# dictionary of form
# c('datetime_column_name' = 'datetime_type')
# 'datetime_type' options: 'time' 'day' 'month' 'year'
dt_dict,
default_dt = 1200,
# allows you to skip NAs,
# FALSE reassigns to default_dt
ignore_dt_na = TRUE,
# allows user to specify other values to
# reassign to default_dt, can be single
# or vector
replace_value = FALSE,
) {
# loop through every provided datetime_type
for (time_col in names(dt_dict)) {
# loop through every time value
for(i in 1:nrow(df[time_col])) {
# if it is NA
if (is.na(df[time_col][i, ])) {
# pass if ignore_dt_na is TRUE
if (ignore_dt_na) {
next()
# replace with default time if FALSE
} else {
df[time_col][i, ] <- default_dt
}
# if it is equal to replace_value
} else if (df[time_col][i, ] %in% replace_value) {
# replace with the default
df[time_col][i, ] <- default_dt
# if the default time is midnight
} else if (dt_dict[time_col] == 'time') {
# make sure that all entries have 4 digits
if(nchar(df[time_col][i, ]) == 1) {
df[time_col][i, ] <- paste0(000, df[time_col][i, ])
} else if(nchar(df[time_col][i, ]) == 2) {
df[time_col][i, ] <- paste0(00, df[time_col][i, ])
} else if(nchar(df[time_col][i, ]) == 3) {
df[time_col][i, ] <- paste0(0, df[time_col][i, ])
} else if(nchar(df[time_col][i, ]) == 4) {
df[time_col][i, ] <- as.character(df[time_col][i, ])
} else if(nchar(df[time_col][i, ]) > 4) {
print("ERROR: greater than 4 character entry in the time column")
}
} else if (dt_dict[time_col] == 'day'| dt_dict[time_col] == 'month') {
if(nchar(df[time_col][i, ]) == 1) {
df[time_col][i, ] <- paste0(0, df[time_col][i, ])
} else if(nchar(df[time_col][i, ]) == 2) {
df[time_col][i, ] <- as.character(df[time_col][i, ])
} else if(nchar(df[time_col][i, ]) > 2) {
print("ERROR: greater than 2 character entry in the month column")
}
} else if (dt_dict[time_col] == 'year' ) {
if(nchar(df[time_col][i, ]) == 1) {
df[time_col][i, ] <- paste0(200, df[time_col][i, ])
} else if(nchar(df[time_col][i, ]) == 2) {
df[time_col][i, ] <- paste0(20, df[time_col][i, ])
} else if(nchar(df[time_col][i, ]) == 3) {
df[time_col][i, ] <- paste0(2, df[time_col][i, ])
} else if(nchar(df[time_col][i, ]) == 4) {
df[time_col][i, ] <- as.character(df[time_col][i, ])
} else if(nchar(df[time_col][i, ]) > 4) {
print("ERROR: greater than 4 character entry in the year column")
}
} else {
print("ERROR: incorrect datetime type, options are 'time' 'day' 'month' 'year'")
}
}
}
return(df)
}
datetime_clean <- function(df,
# dictionary of form: c('datetime_column_name' = 'datetime_type')  'datetime_type' options: 'time' 'day' 'month' 'year'
dt_dict,
default_dt = 1200,
# allows you to skip NAs,
# FALSE reassigns to default_dt
ignore_dt_na = TRUE,
# allows user to specify other values to
# reassign to default_dt, can be single
# or vector
replace_value = FALSE,
) {
# loop through every provided datetime_type
for (time_col in names(dt_dict)) {
# loop through every time value
for(i in 1:nrow(df[time_col])) {
# if it is NA
if (is.na(df[time_col][i, ])) {
# pass if ignore_dt_na is TRUE
if (ignore_dt_na) {
next()
# replace with default time if FALSE
} else {
df[time_col][i, ] <- default_dt
}
# if it is equal to replace_value
} else if (df[time_col][i, ] %in% replace_value) {
# replace with the default
df[time_col][i, ] <- default_dt
# if the default time is midnight
} else if (dt_dict[time_col] == 'time') {
# make sure that all entries have 4 digits
if(nchar(df[time_col][i, ]) == 1) {
df[time_col][i, ] <- paste0(000, df[time_col][i, ])
} else if(nchar(df[time_col][i, ]) == 2) {
df[time_col][i, ] <- paste0(00, df[time_col][i, ])
} else if(nchar(df[time_col][i, ]) == 3) {
df[time_col][i, ] <- paste0(0, df[time_col][i, ])
} else if(nchar(df[time_col][i, ]) == 4) {
df[time_col][i, ] <- as.character(df[time_col][i, ])
} else if(nchar(df[time_col][i, ]) > 4) {
print("ERROR: greater than 4 character entry in the time column")
}
} else if (dt_dict[time_col] == 'day'| dt_dict[time_col] == 'month') {
if(nchar(df[time_col][i, ]) == 1) {
df[time_col][i, ] <- paste0(0, df[time_col][i, ])
} else if(nchar(df[time_col][i, ]) == 2) {
df[time_col][i, ] <- as.character(df[time_col][i, ])
} else if(nchar(df[time_col][i, ]) > 2) {
print("ERROR: greater than 2 character entry in the month column")
}
} else if (dt_dict[time_col] == 'year' ) {
if(nchar(df[time_col][i, ]) == 1) {
df[time_col][i, ] <- paste0(200, df[time_col][i, ])
} else if(nchar(df[time_col][i, ]) == 2) {
df[time_col][i, ] <- paste0(20, df[time_col][i, ])
} else if(nchar(df[time_col][i, ]) == 3) {
df[time_col][i, ] <- paste0(2, df[time_col][i, ])
} else if(nchar(df[time_col][i, ]) == 4) {
df[time_col][i, ] <- as.character(df[time_col][i, ])
} else if(nchar(df[time_col][i, ]) > 4) {
print("ERROR: greater than 4 character entry in the year column")
}
} else {
print("ERROR: incorrect datetime type, options are 'time' 'day' 'month' 'year'")
}
}
}
return(df)
}
